"""
系统管理API，用于密钥生成和系统初始化
"""

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.deps import get_db
from app.jwt_auth import AuthenticatedUser, require_jwt_token
from app.logging_config import logger
from app.services.key_management_service import (
    APIKeyGenerationError,
    generate_system_secret_key,
    initialize_system_admin,
    KeyManagementServiceError,
    rotate_system_secret_key,
    UserCreationError,
    validate_key_strength,
)
from app.settings import settings
from app.schemas.system import (
    KeyValidationRequest,
    KeyValidationResponse,
    ProviderLimitsResponse,
    ProviderLimitsUpdateRequest,
    SecretKeyGenerationRequest,
    SecretKeyResponse,
    SystemAdminInitRequest,
    SystemAdminInitResponse,
)

router = APIRouter(tags=["system"], prefix="/system")


@router.post("/secret-key/generate", response_model=SecretKeyResponse)
def generate_secret_key(
    request: SecretKeyGenerationRequest,
    current_user: AuthenticatedUser = Depends(require_jwt_token),
) -> SecretKeyResponse:
    """
    生成系统主密钥
    
    Args:
        request: 密钥生成请求
        current_user: 当前认证用户
        
    Returns:
        生成的系统密钥
        
    Raises:
        HTTPException: 如果用户不是超级用户
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="只有超级管理员可以生成系统密钥",
        )
    
    try:
        secret_key = generate_system_secret_key(request.length)
        logger.warning(f"System secret key generated by superuser {current_user.username}")
        return SecretKeyResponse(secret_key=secret_key)
    except KeyManagementServiceError as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate secret key: {str(exc)}",
        )


@router.post("/admin/init", response_model=SystemAdminInitResponse)
def init_system_admin(
    request: SystemAdminInitRequest,
    db: Session = Depends(get_db),
) -> SystemAdminInitResponse:
    """
    初始化系统管理员账户
    
    Args:
        request: 初始化请求
        db: 数据库会话
        
    Returns:
        管理员凭证
        
    Raises:
        HTTPException: 如果系统已有用户或初始化失败
    """
    try:
        admin_credentials = initialize_system_admin(
            session=db,
            username=request.username,
            email=request.email,
            display_name=request.display_name,
        )
        
        return SystemAdminInitResponse(
            username=admin_credentials["username"],
            email=admin_credentials["email"],
            password=admin_credentials["password"],
            api_key=admin_credentials["api_key"],
        )
    except KeyManagementServiceError as exc:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(exc),
        )
    except Exception as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to initialize system admin: {str(exc)}",
        )


@router.post("/secret-key/rotate", response_model=SecretKeyResponse)
def rotate_secret_key(
    current_user: AuthenticatedUser = Depends(require_jwt_token),
) -> SecretKeyResponse:
    """
    轮换系统主密钥
    
    Warning: 这将使所有现有的密码哈希和API密钥失效！
    
    Args:
        current_user: 当前认证用户
        
    Returns:
        新生成的系统密钥
        
    Raises:
        HTTPException: 如果用户不是超级用户
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="只有超级管理员可以轮换系统密钥",
        )
    
    try:
        new_key = rotate_system_secret_key()
        logger.error(f"System secret key rotation initiated by superuser {current_user.username}")
        return SecretKeyResponse(secret_key=new_key)
    except KeyManagementServiceError as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to rotate secret key: {str(exc)}",
        )


@router.post("/key/validate", response_model=KeyValidationResponse)
def validate_key(
    request: KeyValidationRequest,
) -> KeyValidationResponse:
    """
    验证密钥强度
    
    Args:
        request: 验证请求
        
    Returns:
        验证结果
    """
    is_valid = validate_key_strength(request.key)
    
    if is_valid:
        message = "密钥强度足够"
    else:
        message = "密钥强度不足，建议使用更长的随机密钥"
    
    return KeyValidationResponse(is_valid=is_valid, message=message)


@router.get("/provider-limits", response_model=ProviderLimitsResponse)
def get_provider_limits(
    current_user: AuthenticatedUser = Depends(require_jwt_token),
) -> ProviderLimitsResponse:
    """
    获取系统中与 Provider 相关的配额与审核配置。
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="只有超级管理员可以查看提供商限制配置",
        )

    return ProviderLimitsResponse(
        default_user_private_provider_limit=settings.default_user_private_provider_limit,
        max_user_private_provider_limit=settings.max_user_private_provider_limit,
        require_approval_for_shared_providers=settings.require_approval_for_shared_providers,
    )


@router.put("/provider-limits", response_model=ProviderLimitsResponse)
def update_provider_limits(
    payload: ProviderLimitsUpdateRequest,
    current_user: AuthenticatedUser = Depends(require_jwt_token),
) -> ProviderLimitsResponse:
    """
    更新系统中的 Provider 限制配置（仅当前进程内生效）。
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="只有超级管理员可以更新提供商限制配置",
        )

    # 简单的范围校验：默认上限不能超过最大上限
    if payload.default_user_private_provider_limit > payload.max_user_private_provider_limit:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="默认私有提供商数量上限不能大于最大可配置上限",
        )

    # 直接更新 settings 实例；重启进程后会回到 env 配置
    settings.default_user_private_provider_limit = (
        payload.default_user_private_provider_limit
    )
    settings.max_user_private_provider_limit = payload.max_user_private_provider_limit
    settings.require_approval_for_shared_providers = (
        payload.require_approval_for_shared_providers
    )

    return ProviderLimitsResponse(
        default_user_private_provider_limit=settings.default_user_private_provider_limit,
        max_user_private_provider_limit=settings.max_user_private_provider_limit,
        require_approval_for_shared_providers=settings.require_approval_for_shared_providers,
    )


@router.get("/status")
def get_system_status(
    current_user: AuthenticatedUser = Depends(require_jwt_token),
) -> dict:
    """
    获取系统状态
    
    Args:
        current_user: 当前认证用户
        
    Returns:
        系统状态信息
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="只有超级管理员可以查看系统状态",
        )
    
    # 这里可以添加更多的系统状态检查
    status_info = {
        "status": "healthy",
        "message": "系统运行正常",
    }
    
    return status_info


__all__ = ["router"]
